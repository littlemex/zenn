# MCP 公式ドキュメント情報

このファイルは、Model Context Protocol (MCP) の公式ドキュメントから収集した情報をまとめたものです。chapter1.md の整理のために参照できます。

## 1. イントロダクション

### MCPとは
- MCP は、アプリケーションが LLM にコンテキスト（文脈情報）を提供するための標準化されたオープンプロトコル
- AI アプリケーションのための「USB-C」のようなもの
  - USB-C が様々なデバイスを周辺機器に接続する標準的な方法を提供するように
  - MCP は AI モデルを様々なデータソースやツールに接続する標準的な方法を提供

### なぜMCPが必要か
- 事前構築された統合機能を直接利用可能
- LLM プロバイダーやベンダー間の切り替えが容易
- インフラストラクチャ内でのデータ保護
- セキュリティのベストプラクティスに基づく実装

### 一般的なアーキテクチャ
- MCP はクライアント-サーバーアーキテクチャに従う
- ホストアプリケーションは複数のサーバーに接続可能
- 主要コンポーネント：
  - MCP ホスト：Claude Desktop、IDE、AI ツールなど
  - MCP クライアント：サーバーとの 1:1 接続を維持
  - MCP サーバー：標準化されたプロトコルを通じて特定の機能を提供
  - ローカルデータソース：コンピュータのファイル、データベース、サービス
  - リモートサービス：インターネット経由でアクセス可能な外部システム

## 2. アーキテクチャ

### 概要
- MCP はクライアント-サーバーアーキテクチャを採用
  - ホスト：LLM アプリケーション（Claude Desktop や IDE など）
  - クライアント：サーバーとの 1:1 接続を維持
  - サーバー：クライアントにコンテキスト、ツール、プロンプトを提供

### コアコンポーネント

#### プロトコル層
- メッセージフレーミング、リクエスト/レスポンスのリンク、高レベルの通信パターンを処理
- 主要クラス：`Protocol`、`Client`、`Server`

#### トランスポート層
- クライアントとサーバー間の実際の通信を処理
- 複数のトランスポートメカニズムをサポート：
  1. **標準入出力（stdio）トランスポート**
     - 標準入出力を使用した通信
     - ローカルプロセスに最適
  2. **HTTP と SSE トランスポート**
     - サーバーからクライアントへのメッセージに Server-Sent Events を使用
     - クライアントからサーバーへのメッセージに HTTP POST を使用

- すべてのトランスポートは [JSON-RPC](https://www.jsonrpc.org/) 2.0 を使用してメッセージを交換

#### メッセージタイプ
1. **リクエスト**：相手側からの応答を期待
2. **結果**：リクエストへの成功応答
3. **エラー**：リクエストが失敗したことを示す
4. **通知**：応答を期待しない一方向のメッセージ

### 接続ライフサイクル

#### 1. 初期化
1. クライアントがプロトコルバージョンと機能を含む `initialize` リクエストを送信
2. サーバーがプロトコルバージョンと機能で応答
3. クライアントが確認として `initialized` 通知を送信
4. 通常のメッセージ交換が開始

#### 2. メッセージ交換
- **リクエスト-レスポンス**：クライアントまたはサーバーがリクエストを送信し、相手が応答
- **通知**：どちらかが一方向のメッセージを送信

#### 3. 終了
- `close()` による正常なシャットダウン
- トランスポートの切断
- エラー条件

### エラー処理
- 標準エラーコード（ParseError、InvalidRequest など）
- SDK とアプリケーションは独自のエラーコードを定義可能
- エラーはリクエストへの応答、トランスポートのエラーイベント、プロトコルレベルのエラーハンドラを通じて伝播

### セキュリティ考慮事項
1. **トランスポートセキュリティ**
   - リモート接続には TLS を使用
   - 接続元を検証
   - 必要に応じて認証を実装

2. **メッセージ検証**
   - すべての受信メッセージを検証
   - 入力をサニタイズ
   - メッセージサイズの制限を確認
   - JSON-RPC フォーマットを検証

3. **リソース保護**
   - アクセス制御を実装
   - リソースパスを検証
   - リソース使用状況を監視
   - リクエストのレート制限

4. **エラー処理**
   - 機密情報を漏洩しない
   - セキュリティ関連のエラーをログに記録
   - 適切なクリーンアップを実装
   - DoS シナリオに対処

## 3. リソース

### 概要
- リソースは、サーバーがクライアントに公開し、LLM の対話のコンテキストとして使用できるデータやコンテンツ
- **アプリケーション制御型**：クライアントアプリケーションがいつどのように使用するかを決定
- 様々な種類のデータを表現可能：
  - ファイルの内容
  - データベースレコード
  - API レスポンス
  - ライブシステムデータ
  - スクリーンショットや画像
  - ログファイル
  - その他

### リソース URI
- リソースは URI で識別：`[protocol]://[host]/[path]`
- 例：
  - `file:///home/user/documents/report.pdf`
  - `postgres://database/customers/schema`
  - `screen://localhost/display1`

### リソースタイプ
1. **テキストリソース**
   - UTF-8 エンコードのテキストデータ
   - ソースコード、設定ファイル、ログファイルなどに適している

2. **バイナリリソース**
   - base64 でエンコードされた生のバイナリデータ
   - 画像、PDF、音声ファイルなどに適している

### リソースの発見
1. **直接リソース**
   - サーバーは `resources/list` エンドポイントを通じて具体的なリソースのリストを公開
   - 各リソースには URI、名前、説明（オプション）、MIME タイプ（オプション）、サイズ（オプション）が含まれる

2. **リソーステンプレート**
   - 動的リソースの場合、サーバーは URI テンプレートを公開
   - クライアントはこれを使用して有効なリソース URI を構築

### リソースの読み取り
- クライアントはリソース URI を指定して `resources/read` リクエストを行う
- サーバーはリソースの内容のリストで応答
- 1つの `resources/read` リクエストに対して複数のリソースを返すことが可能

### リソースの更新
- MCP はリソースのリアルタイム更新をサポート：
  1. **リスト変更**：サーバーは `notifications/resources/list_changed` 通知でリソースリストの変更を通知
  2. **コンテンツ変更**：クライアントは特定のリソースの更新をサブスクライブ可能

### セキュリティ考慮事項
- すべてのリソース URI を検証
- 適切なアクセス制御を実装
- ディレクトリトラバーサルを防ぐためにファイルパスをサニタイズ
- バイナリデータの処理に注意
- リソース読み取りのレート制限を検討
- リソースアクセスを監査
- 機密データを転送中に暗号化
- MIME タイプを検証
- 長時間実行される読み取りのタイムアウトを実装
- リソースのクリーンアップを適切に処理

## 4. プロンプト

### 概要
- プロンプトは、サーバーが再利用可能なプロンプトテンプレートとワークフローを定義し、クライアントがユーザーと LLM に簡単に提示できるようにする機能
- **ユーザー制御型**：ユーザーが明示的に選択して使用することを意図してサーバーからクライアントに公開

### プロンプト構造
```
{
  name: string;              // プロンプトの一意の識別子
  description?: string;      // 人間が読める説明
  arguments?: [              // 引数のオプションリスト
    {
      name: string;          // 引数の識別子
      description?: string;  // 引数の説明
      required?: boolean;    // 引数が必須かどうか
    }
  ]
}
```

### プロンプトの発見
- クライアントは `prompts/list` エンドポイントを通じて利用可能なプロンプトを発見

### プロンプトの使用
- クライアントは `prompts/get` リクエストを行ってプロンプトを使用
- サーバーは説明とメッセージの配列を返す

### 動的プロンプト
1. **埋め込みリソースコンテキスト**
   - プロンプトにリソースを埋め込み可能
   - 例：ログとコードファイルを分析するプロンプト

2. **マルチステップワークフロー**
   - 複数のステップを持つ対話ワークフローを定義可能

### セキュリティ考慮事項
- すべての引数を検証
- ユーザー入力をサニタイズ
- レート制限を検討
- アクセス制御を実装
- プロンプト使用を監査
- 機密データを適切に処理
- 生成されたコンテンツを検証
- タイムアウトを実装
- プロンプトインジェクションリスクを考慮
- セキュリティ要件を文書化

## 5. ツール

### 概要
- ツールは、サーバーが実行可能な機能をクライアントに公開し、LLM が外部システムと対話し、計算を実行し、現実世界でアクションを実行できるようにする機能
- **モデル制御型**：AI モデルが自動的に呼び出せるようにサーバーからクライアントに公開（ヒューマンインザループで承認を得る）

### ツール定義構造
```
{
  name: string;          // ツールの一意の識別子
  description?: string;  // 人間が読める説明
  inputSchema: {         // ツールのパラメータの JSON スキーマ
    type: "object",
    properties: { ... }  // ツール固有のパラメータ
  },
  annotations?: {        // ツールの動作に関するオプションのヒント
    title?: string;      // ツールの人間が読めるタイトル
    readOnlyHint?: boolean;    // true の場合、環境を変更しない
    destructiveHint?: boolean; // true の場合、破壊的な更新を実行する可能性がある
    idempotentHint?: boolean;  // true の場合、同じ引数での繰り返し呼び出しは追加の効果がない
    openWorldHint?: boolean;   // true の場合、外部エンティティと対話する
  }
}
```

### ツールパターンの例
1. **システム操作**
   - ローカルシステムと対話するツール
   - 例：シェルコマンドの実行

2. **API 統合**
   - 外部 API をラップするツール
   - 例：GitHub の Issue 作成

3. **データ処理**
   - データを変換または分析するツール
   - 例：CSV ファイルの分析

### ツールアノテーション
- ツールの動作に関する追加のメタデータを提供
- クライアントがツールの提示と管理方法を理解するのに役立つ
- セキュリティ決定に依存すべきではないヒント

#### 利用可能なツールアノテーション
| アノテーション | タイプ | デフォルト | 説明 |
|--------------|-------|----------|------|
| title | string | - | UI 表示に役立つツールの人間が読めるタイトル |
| readOnlyHint | boolean | false | true の場合、ツールは環境を変更しないことを示す |
| destructiveHint | boolean | true | true の場合、ツールは破壊的な更新を実行する可能性がある |
| idempotentHint | boolean | false | true の場合、同じ引数での繰り返し呼び出しは追加の効果がない |
| openWorldHint | boolean | true | true の場合、ツールは「オープンワールド」の外部エンティティと対話する可能性がある |

### エラー処理
- ツールエラーは MCP プロトコルレベルのエラーではなく、結果オブジェクト内で報告すべき
- これにより LLM がエラーを確認し、潜在的に処理できる
- エラー発生時：
  1. 結果の `isError` を `true` に設定
  2. `content` 配列にエラーの詳細を含める

### セキュリティ考慮事項

#### 入力検証
- すべてのパラメータをスキーマに対して検証
- ファイルパスとシステムコマンドをサニタイズ
- URL と外部識別子を検証
- パラメータのサイズと範囲を確認
- コマンドインジェクションを防止

#### アクセス制御
- 必要に応じて認証を実装
- 適切な認可チェックを使用
- ツール使用を監査
- リクエストのレート制限
- 悪用を監視

## 6. サンプリング

### 概要
- サンプリングは、サーバーがクライアントを通じて LLM の補完をリクエストできるようにする機能
- 高度なエージェント動作を可能にしながら、セキュリティとプライバシーを維持
- Claude Desktop クライアントではまだサポートされていない

### サンプリングの仕組み
1. サーバーがクライアントに `sampling/createMessage` リクエストを送信
2. クライアントがリクエストをレビューし、修正可能
3. クライアントが LLM からサンプリング
4. クライアントが補完をレビュー
5. クライアントが結果をサーバーに返す

### メッセージフォーマット
- 標準化されたメッセージフォーマットを使用
- `messages` 配列に会話履歴を含む
- `modelPreferences` オブジェクトでモデル選択の設定が可能
- `systemPrompt` フィールドで特定のシステムプロンプトをリクエスト可能
- `includeContext` パラメータで含めるコンテキストを指定
- `temperature`、`maxTokens`、`stopSequences` などのサンプリングパラメータ

### ヒューマンインザループコントロール
- サンプリングは人間の監視を念頭に設計
- クライアントはユーザーに提案されたプロンプトを表示
- ユーザーはプロンプトを修正または拒否可能
- システムプロンプトはフィルタリングまたは修正可能
- コンテキスト含有はクライアントによって制御
- クライアントはユーザーに補完を表示
- ユーザーは補完を修正または拒否可能
- ユーザーは使用するモデルを制御

### セキュリティ考慮事項
- すべてのメッセージコンテンツを検証
- 機密情報をサニタイズ
- 適切なレート制限を実装
- サンプリング使用を監視
- データを転送中に暗号化
- ユーザーデータのプライバシーを処理
- サンプリングリクエストを監査
- コスト露出を制御
- タイムアウトを実装
- モデルエラーを適切に処理

## 7. トランスポート

### メッセージフォーマット
- MCP は [JSON-RPC](https://www.jsonrpc.org/) 2.0 をワイヤーフォーマットとして使用
- トランスポート層は MCP プロトコルメッセージを JSON-RPC フォーマットに変換し、受信した JSON-RPC メッセージを MCP プロトコルメッセージに変換

#### JSON-RPC メッセージタイプ
1. **リクエスト**
   ```
   {
     jsonrpc: "2.0",
     id: number | string,
     method: string,
     params?: object
   }
   ```

2. **レスポンス**
   ```
   {
     jsonrpc: "2.0",
     id: number | string,
     result?: object,
     error?: {
       code: number,
       message: string,
       data?: unknown
     }
   }
   ```

3. **通知**
   ```
   {
     jsonrpc: "2.0",
     method: string,
     params?: object
   }
   ```

### 組み込みトランスポートタイプ

#### 標準入出力（stdio）
- 標準入出力ストリームを通じた通信を可能にする
- ローカル統合やコマンドラインツールに特に有用
- 使用ケース：
  - コマンドラインツールの構築
  - ローカル統合の実装
  - シンプルなプロセス通信
  - シェルスクリプトとの連携

#### サーバー送信イベント（SSE）
- サーバーからクライアントへのストリーミングに HTTP と SSE を使用
- クライアントからサーバーへの通信に HTTP POST を使用
- 使用ケース：
  - サーバーからクライアントへのストリーミングのみが必要な場合
  - 制限されたネットワークでの作業
  - シンプルな更新の実装

##### セキュリティ警告：DNS リバインディング攻撃
- SSE トランスポートは適切に保護されていない場合、DNS リバインディング攻撃に脆弱
- 防止策：
  1. 受信 SSE 接続の Origin ヘッダーを常に検証
  2. ローカルで実行する場合、サーバーをすべてのネットワークインターフェース（0.0.0.0）にバインドせず、localhost（127.0.0.1）のみにバインド
  3. すべての SSE 接続に適切な認証を実装

### セキュリティ考慮事項

#### 認証と認可
- 適切な認証メカニズムを実装
- クライアント認証情報を検証
- セキュアなトークン処理を使用
- 認可チェックを実装

#### データセキュリティ
- ネットワークトランスポートに TLS を使用
- 機密データを暗号化
- メッセージの整合性を検証
- メッセージサイズ制限を実装
- 入力データをサニタイズ

#### ネットワークセキュリティ
- レート制限を実装
- 適切なタイムアウトを使用
- サービス拒否シナリオに対処
- 異常なパターンを監視
- 適切なファイアウォールルールを実装
- SSE トランスポートの場合、DNS リバインディング攻撃を防ぐために Origin ヘッダーを検証
- ローカル SSE サーバーの場合、すべてのインターフェース（0.0.0.0）ではなく localhost（127.0.0.1）のみにバインド
