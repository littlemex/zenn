---
title: "§24 AgentCore 全体の Auth Capability 解説"
free: true
---

___MCP セキュリティに関する包括的な実装編:___ _MCP のセキュリティに対しての包括的な実装に関する解説_

---

**本 Chapter では Amazon Bedrock AgentCore 全体の Auth Capability について 2025/10 時点の情報で整理します。** 

今後の MCP Auth 使用に関しては appendix に状況や最新仕様を追記していきますが、本 Chapter 把握まで現時点の AgentCore の Auth Capability を整理するものです。

## はじめに

Amazon Bedrock AgentCore の認証・認可機能は、エンタープライズ環境での AI エージェント実装において重要な役割を果たします。本章では、様々なユースケースにおける実現可能性と課題を整理し、現状の制限と将来の展望について解説します。特に日本の企業が直面している課題に焦点を当て、実装アプローチと回避策を提案します。

## 1. 社内向け作業効率化エージェント

### ユースケースの概要と課題

社内向け作業効率化エージェントは、企業内の従業員が業務効率を向上させるために利用するツールです。このユースケースでは、同じアプリケーションを複数のユーザーが利用し、社内 IdP でログインした上で、Google Drive や Jira などの外部サービスにアクセスする必要があります。

このようなシナリオでは、認証・認可の観点から複数の課題が生じます。まず、インバウンド認証では社内 IdP との連携が必要です。次に、アウトバウンド認証では Google Drive のような MCP Server 経由でアクセスするサービスと、Jira のような API Server に直接アクセスするサービスが混在するため、統一的な認証管理が難しくなります。

### 認証・認可フローの詳細

インバウンド認証では、社内 IdP（OIDC 方式）を使用した SSO を実装し、取得した Bearer トークンを Amazon Bedrock AgentCore Runtime に渡すことで認証・認可を行います。Amazon Bedrock AgentCore Identity は必須ではありませんが、トークン検証の標準化、クレームマッピング、トークンの自動更新、複数 IdP との連携簡素化、AWS IAM との統合など、多くの価値を提供します。

アウトバウンド認証では、サービスによって異なるアプローチが必要です。Google Drive のような MCP Server 経由でアクセスするサービスでは、MCP サーバーが OAuth 認証を処理し、ユーザーに認可画面を表示します。ユーザーの認可後、MCP サーバーがトークンを管理しますが、Runtime からユーザーコンテキストをカスタムヘッダーで伝播する必要があります。

一方、Jira のような API Server に直接アクセスする場合、Gateway 経由では 2-legged OAuth のみのサポートという制限があるため、3-legged OAuth が必要な場合は Runtime から直接アクセスする必要があります。この場合、Runtime と Identity の組み合わせで 3-legged OAuth の標準パターンを実装できます。

### 主要な課題と疑問点

クライアント ID やシークレットの管理は、連携するサービスが少数であれば手動管理も許容範囲ですが、多数になると煩雑になります。DCR（Dynamic Client Registration）は理論上この問題を解決できますが、複雑さと運用コストを考えると、少数のサービス連携では必ずしも必要ではありません。Amazon Bedrock AgentCore Identity のクレデンシャルプロバイダー機能を使用することで、管理を一元化できます。

リソースアクセス制御の粒度については、OAuth 認可フローを使用することで、ユーザーごとに異なるスコープを要求し、各サービスの権限モデルに基づいてユーザー固有のアクセス範囲を設定できます。例えば、あるユーザーには読み取り権限のみを付与し、別のユーザーには書き込み権限も付与するといった制御が可能です。

また、インバウンドの Bearer トークンと AWS エージェント ID トークンの交換には、セキュリティ強化、権限の最小化、トークン寿命管理、監査とトレーサビリティといった利点があります。

### 実現可能性とブロッカー

Amazon Bedrock AgentCore Runtime では、JWT Bearer Token 認証による社内 IdP との連携、RequestHeaderConfiguration による JWT トークンの Runtime への伝播、3-legged OAuth による Google Drive へのアクセス、API Key 認証による non-MCP API へのアクセスが可能です。

しかし、MCP Server へのリクエスト時にユーザーコンテキストを伝播する標準的な方法がない点、MCP Server と API Server を混在させる場合の認証フロー管理の複雑さ、各ユーザー・各サービスごとのトークン管理の煩雑さ、MCP Server と API Server それぞれに対する個別の接続コード実装が必要な点がブロッカーとなります。

Amazon Bedrock AgentCore Gateway では、MCP Server の統合、ツールの自動発見・インデックス化、Amazon Bedrock AgentCore Identity を活用した OAuth2 認証管理が可能です。

しかし、現状 Gateway は 2-legged OAuth のみをサポートしているため、ユーザーコンテキストが欠如する点、社内 IdP で認証したユーザーコンテキストを MCP Server に伝播できない点、Jira のような API Server を Gateway に統合する標準的な方法がない点、同一アプリを複数ユーザーが使う場合の権限分離が難しい点がブロッカーとなります。

MCP 仕様自体にも、ユーザーコンテキスト伝播方法の標準化不足、DCR の運用負荷と信頼性問題、2-legged OAuth でのスコープアップグレード制限、エンタープライズ統合の標準不足、MCP/non-MCP 混在環境の標準がないといったブロッカーがあります。

### 実装アプローチと将来展望

短期的には、社内 IdP との OIDC 連携によるインバウンド認証、MCP サーバーと 3-legged OAuth による Google Drive 連携（カスタムヘッダーでユーザーコンテキスト伝播）、Runtime 直接実装と Identity のクレデンシャルプロバイダーによる Jira 連携、アプリケーションレベルでのユーザーコンテキスト管理またはテナントごとの Gateway インスタンス分離によるテナント分離が実現可能です。

中長期的には、Gateway の 3-legged OAuth サポートや JWT propagation 機能の追加、SEP-646 で議論されているエンタープライズ向け ID-JAG メカニズムの標準化と実装、SEP-1299 で検討されている HTTP Message Signatures による新しい認証メカニズム、MCP 仕様の進化による標準的なユーザーコンテキスト伝播方法の確立が期待されます。

現状では、社内向け作業効率化エージェントの実装は技術的に可能ですが、標準化された実装パターンの不足が課題です。Amazon Bedrock AgentCore Identity を活用することで実装を大幅に簡素化でき、将来的には Gateway の機能拡張により、さらに実装が容易になることが期待されます。

## 2. プロダクトに組み込んだ社外向けエージェント

### ユースケースの概要と認証フロー

旅行予約エージェントのような社外向けエージェントアプリケーションでは、エンドユーザーの認証と外部サービスへのアクセス権限管理が重要です。このユースケースでは、ユーザーがエージェントアプリにログインし、アプリを利用する中で、エージェントがユーザーの代理としてリソースの操作を実行するという流れになります。

Amazon Bedrock AgentCore Runtime を使用する場合、ユーザーは標準的な Web アプリケーションのログイン画面で認証を行い、OIDC/OAuth2 フローに従って外部 IdP へリダイレクトされることがあります。ログイン成功後、Web アプリケーションは JWT Bearer トークンを取得し、このトークンを Runtime へのリクエストに含めます。Runtime はトークンを検証し、ユーザーコンテキストを維持します。

アプリ利用中は、トークンの有効期限が切れた場合のみ再認証またはサイレントリフレッシュが発生し、それ以外はシームレスな操作が可能です。エージェントがユーザーの代理としてリソースの操作を実行する際、3-legged OAuth を使用する場合、初回アクセス時にはユーザーに外部リソースへのアクセス承認を求める画面が表示されます。承認後は、トークンが有効な間は承認画面は表示されず、トークン期限切れ時に再度表示される可能性があります。

技術的には、Runtime が `requires_access_token` デコレータを使用して OAuth フローを開始し、ユーザーの承認後、アクセストークンを取得して Token Vault に保存します。以降のリクエストでは保存されたトークンを使用します。

### Gateway と Runtime の比較

Amazon Bedrock AgentCore Gateway を使用する場合、インバウンド認証と通常の利用時の体験は Runtime と同様ですが、エージェントがリソースの操作を実行する際の挙動が異なります。Gateway は現状 2-legged OAuth のみをサポートしているため、ユーザーに承認画面は表示されませんが、その代わりユーザー固有のコンテキストでのアクセスができないというデメリットがあります。

Gateway は 2-legged OAuth を使用して MCP Server にアクセスし、クライアント認証情報フローでアクセストークンを取得します。この場合、ユーザーコンテキストは失われ、エージェント全体で共通のアクセス権限となります。

Runtime と Gateway を比較すると、ユーザーコンテキストの維持、承認画面の表示、セキュリティと透明性、実装の複雑さの観点で違いがあります。Runtime はユーザー固有のコンテキストを維持でき、ユーザーの明示的な承認により透明性が高いですが、3-legged OAuth フローの実装が必要です。一方、Gateway は実装がシンプルですが、ユーザーコンテキストが失われ、ユーザーは自分のデータへのアクセスを個別に承認できないため透明性が低くなります。

### 推奨アプローチ

社外向けエージェントでは、ユーザーのプライバシーと透明性を考慮すると、インバウンド認証には標準的な OIDC/OAuth2 フローを使用し、アウトバウンド認証では個人データアクセス時に Runtime と 3-legged OAuth でユーザーの明示的な承認を取得し、公開データアクセス時に Gateway と 2-legged OAuth でシンプルに実装するというアプローチが推奨されます。

将来的に Gateway が 3-legged OAuth をサポートすれば、より柔軟な実装が可能になるでしょう。

## 3. 開発者向けリモート MCP サーバー認証ユースケース

### ユースケースの概要と課題

企業内の開発者がコーディングエージェントからリモート MCP サーバーを安全に利用するためには、適切な認証・認可の仕組みが必要です。ローカル MCP サーバーでは長期的なアクセストークンを設定ファイルにハードコードするなどのセキュリティ上の懸念があるため、社内に公開されたリモート MCP サーバーを利用する際に、開発者が安全かつ簡単にログインできる仕組みが求められています。

理想的なユーザー体験としては、開発者がコーディングエージェントにリモート MCP サーバーを登録すると、ブラウザが立ち上がってログイン画面が表示され、ログイン後に MCP サーバーが利用可能になるというものです。さらに高度な要件として、各 MCP サーバーごとに個別にログインするのではなく、社内 IdP と連携して一度のログインで複数のサーバーにアクセスできること（SEP-646 関連）や、DCR によるクライアント登録の簡素化が挙げられます。

### 現状のブロッカーと影響

現状では、Amazon Bedrock AgentCore Runtime や Gateway のコード内にユーザーの識別情報や属性情報を安全に伝播させる標準的な方法がなく、特に Gateway が 2-legged OAuth のみをサポートしているため、ユーザー固有のコンテキストが失われるという問題があります。これにより、ユーザーごとのアクセス制御が困難になり、監査やコンプライアンス要件を満たせない可能性があります。

また、現在の Runtime をリモートサーバーとして使用する場合の 3-legged OAuth 認証フローが不十分で、Identity と MCP サーバーの統合が最適化されていないため、理想的なユーザー体験を実現できず、各 MCP サーバーごとに個別の認証が必要になり、開発者の生産性が低下します。

DCR については、MCP 仕様に含まれているものの、実装上の懸念点も指摘されており、セキュリティリスクと運用負荷のバランスが課題となっています。これにより、クライアント ID/シークレットの手動管理が必要となり、開発者のオンボーディングプロセスが複雑化します。

### 現在調査中の認証フローの課題

現在、AgentCore RuntimeにおけるMCPサーバーの認証フローに関して、特に3LO（3-Legged OAuth）フローでのbearer tokenのタイミングに関する課題が報告されています。この問題は、Q CLIのようなエージェントからMCPサーバーを呼び出す際に顕著になります。

具体的には、AgentCore Runtimeがbearer tokenまたはSigV4認証を要求する一方で、3LOフローではbearer tokenがツール呼び出し後に提供されるという時間的なミスマッチが発生します。特に「list tools」などの初期リクエスト時に、bearer tokenが存在しない状態でリクエストを開始する方法が明確になっていません。

現在の認証フローでは、MCPサーバーはメタデータ発見以外のすべてのエンドポイントで認証を要求するため、クライアントをインスタンス化してツールをリストする前に、3LOを開始して認証を設定する必要があります。

この課題に対する潜在的な解決策として、Identityを使用したワークロードアクセストークンによるユーザー分離を実現する3LOの使用が検討されています。この方式では、認証URLを呼び出し元エージェントに返し、ユーザーが認証を提供した後にエージェントが再試行する仕組みが考えられます。

この問題に関しては現在も調査が進行中であり、AWS公式からの明確なガイダンスや解決策の発表が待たれています。今後、新たな情報や公式な解決策が提供された場合は、本書の付録にて最新情報を提供する予定です。

### ロードマップ項目への期待

AWS のロードマップ項目 "Propagate user identity context to agent code" には、以下の機能が期待されています。

まず、ユーザーコンテキスト伝播の標準化です。インバウンド認証で取得したユーザー情報をエージェントコードに安全に伝播し、JWT claims やユーザー属性を標準的に受け渡す方法が確立されることが望まれます。

次に、Gateway 経由のユーザーコンテキスト維持です。Gateway 経由で MCP サーバーにアクセスする際にユーザーコンテキストを維持し、2-legged OAuth の制限を超えた柔軟なユーザー情報伝達が可能になることが期待されます。

さらに、社内 IdP 連携の簡素化です。SEP-646 で議論されている ID-JAG メカニズムが実装され、一度の認証で複数の MCP サーバーへのアクセスが可能になることが望まれます。

### 実装アプローチと将来展望

短期的な回避策としては、Runtime から MCP サーバーへのリクエスト時にカスタムヘッダーでユーザー情報を伝播する方法や、ユーザー認証と MCP サーバーアクセスの間にプロキシレイヤーを導入し、ユーザーコンテキストを維持・変換する方法が考えられます。

中長期的には、Amazon Bedrock AgentCore Identity の機能拡張を活用し、"Propagate user identity context to agent code" の実装を取り入れることや、SEP-646 の標準化と実装を待ち、エンタープライズ向け ID-JAG メカニズムを活用して社内 IdP との統合を標準的な方法で実現することが期待されます。

現在の Amazon Bedrock AgentCore の機能では、開発者向けリモート MCP サーバー認証のユースケースに十分に対応できていません。特に「ユーザーコンテキストの伝播」と「3-legged OAuth 認証フロー」の制限が主要なブロッカーとなっています。ロードマップ項目の具体的な仕様が明らかになれば、これらの課題がどの程度解決されるかを評価できるでしょう。

## 4. マルチテナント MCP サーバー実装ユースケース

### ユースケースの概要と課題

SaaS プロバイダーやパートナー企業が複数の顧客（テナント）向けに単一の MCP サーバーを提供する状況では、テナントごとのデータ分離とアクセス制御が重要な課題となります。理想的な実装では、ユーザーが自社の IdP でログインし、テナント ID を含むトークンが発行され、MCP サーバーがトークンからテナント ID と権限情報を抽出し、テナントごとに適切なデータ分離とアクセス制御を実施するという流れになります。

しかし現状では、Amazon Bedrock AgentCore Runtime や Gateway からエージェントコードへのユーザー ID 伝播機能が不足しており、テナント情報を含む JWT トークンをエージェントコード内で取得できないという問題があります。これにより、マルチテナント環境での適切なアクセス制御が困難になり、テナント間のデータ分離を実装するための標準的な方法がなく、AgentCore を使わない独自実装を検討せざるを得ない状況が生じています。

また、MCP サーバーでのマルチテナント実装の標準的なパターンが未確立で、テナント分離のベストプラクティスが不明確なため、各開発者が独自のマルチテナント実装を行う必要があり、セキュリティリスクや実装の非効率が生じる可能性があります。

### JWT トークン伝播機能への期待

最近リリースされた JWT トークン伝播機能（[ドキュメント](https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-oauth.html#oauth-propagate-jwt-token)）については、エージェントコード内でのトークン取得方法と利用可能な情報の詳細が期待されています。

また、Amazon Bedrock AgentCore Identity と Runtime で同じ Authorizer を設定した場合の挙動や、二重認証を避けるための最適な設定方法についても関心が高まっています。

さらに、マルチテナント MCP サーバー実装のためのベストプラクティスや、テナント ID に基づくデータ分離とアクセス制御の実装例の明確化が求められています。

### 実装アプローチと将来展望

短期的な回避策としては、現状の JWT トークン伝播機能を最大限活用し、エージェントコード内でトークンを解析してテナント情報を抽出する方法や、エージェントコード内でテナント ID に基づくデータ分離ロジックを実装し、データベースやストレージへのアクセス時にテナント ID をフィルタとして使用する方法が考えられます。

中長期的には、Amazon Bedrock AgentCore Identity の拡張機能を活用し、ユーザー ID 伝播機能の詳細仕様を確認した上で、テナント情報を含む JWT クレームの効果的な活用方法を確立することや、AWS サービスチームと協力してマルチテナント MCP サーバーの実装パターンを確立し、セキュリティとスケーラビリティを両立させる設計指針を策定することが期待されます。

## 5. 認証フロー簡素化ユースケース

### ユースケースの概要と課題

複数の認証ポイントを持つシステムでは、ユーザー体験の簡素化が重要な課題となります。現状のアーキテクチャでは、Application → (InboundAuth) → Agent on AgentCore、Agent on AgentCore → (InboundAuth) → MCP on Gateway といった複数の認証ポイントが存在する可能性があり、ユーザーが複数回認証を求められる不便さが生じています。

理想的な実装では、アプリケーションでの 1 回のログインで完結し、同じ IdP を使用した場合に認証情報が適切に伝播され、ユーザーに追加の認証を求めないという流れになります。

しかし現状では、同じ IdP を指定することで OAuth フローを 1 度にできるかが不明確で、Runtime と Gateway で同じ Authorizer を設定した場合の挙動も不明確なため、最適な認証設計が困難になり、ユーザー体験の低下や開発の複雑化が生じています。

また、ドキュメントと SDK コードから見える実装では、Runtime の機能として Agent 呼び出し時の HTTP ヘッダーから Bearer Token を取得可能ですが、Identity との連携や Gateway への伝播の詳細が不明確なため、認証フローの設計に不確実性が生じ、最適な実装パターンの選択が困難になっています。

### 最新のアップデート：アイデンティティ伝播機能

2025年9月に、AgentCore Runtimeに「アイデンティティ伝播」機能が追加されました。この機能により、認証フロー簡素化の課題に対する重要な進展がもたらされました。

**主な特徴と利点**

1. **JWTトークンの伝播**:
   - クライアントからRuntimeへのリクエスト時に、JWTトークンをカスタムヘッダーとして渡すことが可能になりました
   - `RequestHeaderConfiguration` APIを使用して実装でき、ヘッダー名と値を柔軟に設定できます

2. **ユーザーコンテキストの維持**:
   - エージェントコード内でユーザーのアイデンティティ情報に直接アクセスできるようになりました
   - これにより、ユーザー固有の権限に基づいたアクセス制御の実装が容易になります

3. **認証フローの簡素化**:
   - アプリケーションで取得したJWTトークンをRuntimeに直接伝播させることで、二重認証の必要性が軽減されます
   - ユーザー体験の向上と開発の簡素化が同時に実現できます

**実装例**

```python
# AgentCore Runtime設定時のコード例
response = client.create_agent_runtime(
    name="MyRuntime",
    requestHeaderConfiguration={
        "headerName": "Authorization",
        "headerValue": "Bearer ${jwt_token}"
    }
)

# エージェントコード内でのトークン取得例
def my_agent_function(event, context):
    # リクエストヘッダーからJWTトークンを取得
    auth_header = event.get('headers', {}).get('Authorization')
    if auth_header and auth_header.startswith('Bearer '):
        jwt_token = auth_header[7:]  # "Bearer "の後の部分を取得
        # トークンを検証して処理...
```

この機能により、認証フロー簡素化ユースケースにおける多くの課題が解決される可能性があります。特に、アプリケーションからRuntimeへのユーザーコンテキスト伝播が標準化されたことで、一貫した認証体験の実現に近づきました。

詳細は公式ドキュメント（https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/runtime-oauth.html#oauth-propagate-jwt-token）を参照してください。

### 検証アプローチと将来展望

短期的な検証としては、Application → Runtime → Gateway の認証フローで同じ IdP を指定した場合の挙動検証や、JWT トークン伝播機能を使用したユーザーコンテキスト維持の実装テスト、単一認証ポイントでの実装プロトタイプの開発とユーザー体験および開発複雑性の評価が考えられます。

中長期的には、Identity と Runtime の統合認証モデルの確立や、Gateway の IAM 認証機能強化による問題解決の可能性の検討、検証結果に基づく最適な認証フロー設計のベストプラクティス文書化、様々なユースケースに対応する実装パターンの提供が期待されます。

認証フロー簡素化のユースケースでは、ユーザー体験の向上と開発の簡素化を両立させるために、認証ポイント間の適切な連携が重要です。AWS サービスチームとの対話を通じて、同じ IdP を使用した場合の認証情報伝播の挙動や JWT トークン伝播の詳細仕様についての情報を明確にし、最適な認証フロー設計のためのガイダンスを得ることが重要です。

## 総括

Amazon Bedrock AgentCore の認証・認可機能は、様々なユースケースに対応可能ですが、いくつかの共通する課題も存在します。特に、ユーザーコンテキストの伝播、マルチテナント環境でのアクセス制御、認証フローの簡素化といった点で改善の余地があります。

現状では、カスタムヘッダーの使用やアプリケーションレベルでの実装など、回避策を用いることで多くの要件を満たすことができますが、標準化された実装パターンの不足が大きな課題となっています。

2025年9月にリリースされたアイデンティティ伝播機能は、これらの課題に対する重要な一歩となりました。この機能により、ユーザーコンテキストの維持と認証フローの簡素化が進み、より統合された認証体験の実現に近づいています。

将来的には、"Propagate user identity context to agent code" のようなロードマップ項目の実装や、Gateway の 3-legged OAuth サポート、SEP-646 で議論されている ID-JAG メカニズムの標準化などにより、これらの課題が解決されることが期待されます。

AWS サービスチームとの対話を通じて、これらの機能の詳細仕様や実装タイムラインを明確にし、日本の企業が直面している具体的な課題に対する解決策を見出すことが重要です。
