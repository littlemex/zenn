---
title: "ยง11 Streamable HTTP Security"
free: true
---

___Understanding MCP Implementation:___ _Explanation of developer-oriented knowledge necessary to implement MCP vulnerabilities and countermeasures_

---

This chapter's explanation is based on the [specification](https://modelcontextprotocol.io/specification/2025-03-26) from 2025-03-26.

MCP Specification: **Base Protocol (We are here)**, Authorization, Client Features, Server Features, Security Best Practices

In this Chapter, we will explain the security-related implementation of Streamable HTTP in typescript-sdk (tag: 1.12.1). As explained in Chapter 09 and 10, Streamable HTTP uses HTTP and SSE to enable bidirectional communication.

## Streamable HTTP Security

**1. CORS (Cross-Origin Resource Sharing)**

CORS is a security feature implemented by browsers to restrict web pages from making requests to a different domain than the one that served the web page. In the context of MCP, CORS is important when the MCP Client is running in a browser and needs to communicate with an MCP Server on a different domain.

The typescript-sdk implementation includes CORS support in the `StreamableHTTPServerTransport` class. It sets the appropriate CORS headers to allow cross-origin requests:

```typescript
private setCorsHeaders(req: IncomingMessage, res: ServerResponse): void {
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader("Access-Control-Allow-Origin", origin);
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, DELETE, OPTIONS");
    res.setHeader(
      "Access-Control-Allow-Headers",
      "Content-Type, Accept, mcp-session-id, last-event-id"
    );
    res.setHeader("Access-Control-Allow-Credentials", "true");
    res.setHeader("Access-Control-Max-Age", "86400"); // 24 hours
  }
}
```

This implementation allows:
- Any origin that makes a request to access the resource (by reflecting the request origin)
- GET, POST, DELETE, and OPTIONS HTTP methods
- Specific headers including those used by MCP
- Credentials to be included in cross-origin requests
- Preflight request results to be cached for 24 hours

**2. Session Management**

Session management is a critical security feature in Streamable HTTP. It allows the Server to associate multiple requests from the same Client and maintain state across those requests. The typescript-sdk implementation uses a session ID to track Client sessions:

```typescript
private async handlePostRequest(req: IncomingMessage, res: ServerResponse, parsedBody?: unknown): Promise<void> {
  try {
    // ...
    
    // Check for initialization request
    const isInitRequest = messages.some(isInitializedNotification);
    
    // Handle session ID
    if (isInitRequest) {
      if (!this.sessionId && this.sessionIdGenerator) {
        this.sessionId = this.sessionIdGenerator();
        this._initialized = true;
        this._onsessioninitialized?.(this.sessionId);
      }
    }
    
    // Set session ID in response header if available
    if (this.sessionId) {
      res.setHeader("mcp-session-id", this.sessionId);
    }
    
    // ...
  } catch (error) {
    // Error handling
  }
}
```

The session ID is generated by the Server when it receives an initialization request from the Client. The session ID is then included in the response headers and should be included by the Client in subsequent requests.

**3. Input Validation**

Input validation is essential for preventing injection attacks and ensuring the integrity of the system. The typescript-sdk implementation includes validation for JSON-RPC messages using Zod schemas:

```typescript
// Parse and validate the message
let messages: JSONRPCMessage[];
try {
  if (Array.isArray(rawMessage)) {
    messages = rawMessage.map(msg => JSONRPCMessageSchema.parse(msg));
  } else {
    messages = [JSONRPCMessageSchema.parse(rawMessage)];
  }
} catch (error) {
  // Handle validation error
  res.writeHead(400).end(JSON.stringify({
    jsonrpc: "2.0",
    error: {
      code: -32700,
      message: "Parse error"
    },
    id: null
  }));
  return;
}
```

This validation ensures that all messages conform to the JSON-RPC 2.0 specification and prevents malformed or malicious messages from being processed.

**4. Error Handling**

Proper error handling is important for security as it prevents information leakage and ensures the system remains stable even when errors occur. The typescript-sdk implementation includes comprehensive error handling:

```typescript
private async handlePostRequest(req: IncomingMessage, res: ServerResponse, parsedBody?: unknown): Promise<void> {
  try {
    // Normal processing
  } catch (error) {
    // Error handling
    this.onerror?.(error as Error);
    
    if (!res.headersSent) {
      res.writeHead(500).end(JSON.stringify({
        jsonrpc: "2.0",
        error: {
          code: -32000,
          message: "Internal error"
        },
        id: null
      }));
    }
  }
}
```

This implementation catches all exceptions that might occur during request processing and returns appropriate error responses without exposing internal details.

**5. Stream Management**

Proper stream management is important for preventing resource exhaustion and denial of service attacks. The typescript-sdk implementation includes mechanisms to limit the number of streams and clean up resources when they are no longer needed:

```typescript
private async handleGetRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {
  // ...
  
  // Check for existing GET stream
  if (this._streamMapping.get(this._standaloneSseStreamId) !== undefined) {
    // If already exists, return 409 Conflict
    res.writeHead(409).end(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Conflict: Only one SSE stream is allowed per session"
      },
      id: null
    }));
    return;
  }
  
  // ...
  
  // Clean up when the connection is closed
  req.on("close", () => {
    this._streamMapping.delete(this._standaloneSseStreamId);
  });
}
```

This implementation ensures that only one GET stream is allowed per session and cleans up resources when the connection is closed.

**6. Authentication and Authorization**

While the Base Protocol does not require authentication or authorization, the typescript-sdk implementation includes hooks for adding these features:

```typescript
async handleRequest(req: IncomingMessage & { auth?: AuthInfo }, res: ServerResponse, parsedBody?: unknown): Promise<void> {
  // The auth property can be set by middleware
  // and used for authentication and authorization
}
```

The `auth` property can be set by middleware and used to implement authentication and authorization. This allows for extending the security features of the MCP Server.

## Vulnerabilities and Countermeasures

**1. CORS Misconfiguration**

**Vulnerability:** The current implementation reflects the origin header, which could potentially allow any website to make requests to the MCP Server if the Client is running in a browser.

**Countermeasure:** Instead of reflecting the origin header, consider using a whitelist of allowed origins:

```typescript
private setCorsHeaders(req: IncomingMessage, res: ServerResponse): void {
  const origin = req.headers.origin;
  const allowedOrigins = ["https://example.com", "https://api.example.com"];
  
  if (origin && allowedOrigins.includes(origin)) {
    res.setHeader("Access-Control-Allow-Origin", origin);
    // Other CORS headers
  }
}
```

**2. Session Fixation**

**Vulnerability:** If the session ID is not properly validated or can be influenced by the Client, an attacker might be able to force a victim to use a known session ID.

**Countermeasure:** Always generate session IDs on the Server using a secure random number generator and validate incoming session IDs:

```typescript
private validateSessionId(sessionId: string): boolean {
  // Check if the session ID exists in the session store
  // and has not expired
  return this._sessionStore.has(sessionId) && !this._sessionStore.isExpired(sessionId);
}
```

**3. Denial of Service**

**Vulnerability:** An attacker could create many connections or send large messages to exhaust Server resources.

**Countermeasure:** Implement rate limiting, connection limits, and message size limits:

```typescript
private async handlePostRequest(req: IncomingMessage, res: ServerResponse, parsedBody?: unknown): Promise<void> {
  // Check message size
  const contentLength = parseInt(req.headers["content-length"] || "0", 10);
  if (contentLength > this._maxMessageSize) {
    res.writeHead(413).end(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Message too large"
      },
      id: null
    }));
    return;
  }
  
  // Check rate limit
  if (this._rateLimiter.isLimited(req.socket.remoteAddress)) {
    res.writeHead(429).end(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Too many requests"
      },
      id: null
    }));
    return;
  }
  
  // Normal processing
}
```

**4. Information Leakage**

**Vulnerability:** Error messages might reveal sensitive information about the Server implementation or internal state.

**Countermeasure:** Use generic error messages and log detailed errors server-side:

```typescript
private handleError(error: Error, res: ServerResponse): void {
  // Log detailed error for debugging
  console.error("Internal error:", error);
  
  // Return generic error to client
  if (!res.headersSent) {
    res.writeHead(500).end(JSON.stringify({
      jsonrpc: "2.0",
      error: {
        code: -32000,
        message: "Internal error"
      },
      id: null
    }));
  }
}
```

**5. Cross-Site Request Forgery (CSRF)**

**Vulnerability:** If the MCP Server relies solely on cookies for authentication, it might be vulnerable to CSRF attacks.

**Countermeasure:** Use CSRF tokens or ensure that all state-changing operations require a custom header that cannot be set by cross-site requests:

```typescript
private validateCsrfToken(req: IncomingMessage): boolean {
  const csrfToken = req.headers["x-csrf-token"];
  const sessionId = req.headers["mcp-session-id"];
  
  if (!csrfToken || !sessionId) {
    return false;
  }
  
  return this._sessionStore.validateCsrfToken(sessionId as string, csrfToken as string);
}
```

## Summary

In this Chapter, we explained the security-related implementation of Streamable HTTP in typescript-sdk. We covered CORS, session management, input validation, error handling, stream management, and hooks for authentication and authorization. We also discussed potential vulnerabilities and countermeasures.

While the typescript-sdk implementation provides a good foundation for security, it's important to remember that security is a continuous process. As the MCP specification and implementation evolve, new security considerations will emerge. Always stay updated with the latest security best practices and adapt your implementation accordingly.

In the next Chapter, we will explain the MCP Authorization specification, which builds on the Base Protocol to provide more robust security features.
