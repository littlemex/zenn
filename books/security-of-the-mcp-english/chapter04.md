---
title: "§04 Overview of MCP"
free: true
---

___Understanding MCP:___ _Explanation of prerequisite knowledge needed to understand MCP vulnerabilities and countermeasures_

---

This chapter's explanation is based on the [specification](https://modelcontextprotocol.io/specification/2025-06-18) from 2025-06-18.

The components that make up MCP include MCP Client, MCP Server, and MCP Host. In this Chapter, we will examine the overall picture of MCP.

> MCP Component Diagram

![040101](/images/books/security-of-the-mcp/fig_c04_s01_01.png)

## Components

**MCP Host**

MCP Host refers to integrated development environments, AI applications, and similar systems. The host provides a user interface and manages interactions with the AI model. It receives user input, forwards it to the AI model in an appropriate format, and displays the results. The host can create and manage multiple Clients, allowing it to communicate with various MCP Servers.

**MCP Client**

MCP Client is generated by the MCP Host application and maintains isolated connections for each MCP Server. Communication with the MCP Server involves exchanging JSON-RPC 2.0-based messages.

The Client has 3 functions: **Roots, Sampling, and Elicitation**. The availability of these functions is configured on the Client side, and this information is exchanged during connection with the Server. The Server can only use the functions that are available.

**Roots** is a security function that explicitly restricts the Server's file system operation range based on configuration. This function can prevent access to sensitive information such as authentication credentials. **Sampling** is a function that allows the Server to indirectly access the LLM. Why is this function necessary? The Server's primary responsibility is to provide tools, and by specification, it does not have a direct connection to the LLM. This function allows the Server to indirectly utilize the LLM through the Client. **Elicitation** is a function that allows the Server to indirectly request information input from the user. For example, if the Server needs to ask the user for their Github username, it can use Elicitation to obtain the username.

**MCP Server**

MCP Server provides **Resources, Prompts, and Tools** to the Client. **Resources** provide prompt templates for the AI model to use, **Prompts** provide template messages for users, and **Tools** provide tool usage functionality for the AI model.

You may have only seen or used cases where the MCP Server is on a local machine. Streamable HTTP, which we will explain in detail later, can also have MCP Servers existing remotely.

**MCP Functions Summary**

| Function | Role | Client Responsibility | Server Responsibility |
|------|------|------------|------------|
| Roots | Restrict Server's file system operation range | Define and manage accessible range | Operate only within defined boundaries |
| Sampling | Allow Server to use LLM | Manage access to LLM | Provide appropriate prompts and arguments, process results |
| Elicitation | Collect structured data from users | Request information input from users, validate input and send to Server | Define schema and specify required data structure |
| Prompts | Provide prompt templates | Retrieve templates, present to users and use them | Define templates and provide schema for arguments |
| Resources | Provide resources such as files | Retrieve resources, display and use appropriately | Manage resources and make them accessible via URI |
| Tools | Provide interaction functionality with external systems | Call tools, process and display results | Implement tools and define input/output schemas |

## Base Protocol

MCP adopts [JSON-RPC 2.0](https://www.jsonrpc.org/specification) as its base protocol and extends it for tool usage. Please refer to the JSON-RPC 2.0 specification for details. One main difference at the protocol level between MCP and JSON-RPC 2.0 is that MCP requires request IDs and does not allow null. The message structure is also slightly more restrictive than JSON-RPC 2.0, prohibiting duplicate request IDs.

While MCP adds specific functionality to JSON-RPC 2.0, these additions are primarily implemented using the _params_ field in request objects and the _result_ field in response objects defined in JSON-RPC 2.0. In simple terms, MCP defines additional specifications using the areas in JSON-RPC 2.0 that can handle arbitrary values.

JSON-RPC 2.0 is a protocol that does not depend on the underlying transport layer (which also encompasses the application layer in the OSI reference model). In simpler terms, **you can use the same data format whether it's HTTP, WebSocket, or inter-process communication**.

_Requests object_ 

```json
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: { # MCP-specific additional specifications are defined in this params area
    [key: string]: unknown;
  };
}
```

_Notifications object (subobject of Requests)_

```json
{ # Does not have an id
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

_Responses object_

```json
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {  # MCP-specific additional specifications are defined in this result area
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

### Other MCP Protocol Functional Specifications

**Batch Processing**

As defined in JSON-RPC 2.0, clients may send an array filled with request objects to send multiple request objects simultaneously. The receiving side must support batch processing.

**Authentication**

While not defined in JSON-RPC 2.0, authentication is recommended as a SHOULD. However, the authentication mechanism still seems to be under discussion.

**Schema**

The complete specification of the protocol is defined as a [Typescript schema](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/schema/2025-03-26/schema.ts).

## Summary

In this Chapter, we explained the components that appear in MCP and the Base Protocol between Client ↔ Server. The MCP Base Protocol is based on JSON-RPC 2.0 and provides schema definitions for additional functionality. Future protocol extensions will likely continue to use JSON-RPC 2.0 to maintain backward compatibility. In subsequent Chapters, we will explain the detailed functionality of each MCP component, the sequence of Protocol exchanges, and more.
