---
title: "§04 MCP Overview"
free: true
---

___MCP Understanding Section:___  _Explanation of prerequisite knowledge necessary to understand MCP vulnerabilities and countermeasures_

---

This chapter's explanation is based on the [specification](https://modelcontextprotocol.io/specification/2025-06-18) from 2025-06-18.

MCP consists of the following main components:

- **Base Protocol**: Core JSON-RPC message types
- **Lifecycle Management**: Connection initialization, capability negotiation, session control
- **Authorization**: Authentication and authorization framework for HTTP-based transport
- **Server Features**: Resources, prompts, and tools exposed by the Server
- **Client Features**: Sampling and root directory listing provided by the Client
- **Utilities**: Cross-cutting concerns such as logging and argument completion

All implementations must support the **Base Protocol** and **Lifecycle Management** components, while other components are implemented based on the specific needs of the application. Lifecycle Management will be explained in subsequent Chapters.

The main actors that make up MCP include MCP Client, MCP Server, and MCP Host. In this Chapter, we will examine the overall picture of MCP.

> MCP Component Diagram

![040101](/images/books/security-of-the-mcp/fig_c04_s01_01.png)

## Components

**MCP Host**

MCP Host refers to integrated development environments, AI applications, and similar systems. The host provides a user interface and manages interactions with the AI model. It receives user input, forwards it to the AI model in an appropriate format, and displays the results. The host can create and manage multiple Clients, allowing it to communicate with various MCP Servers. Furthermore, the Host plays a crucial role in enforcing Client connection permissions, security policies, and consent requirements. It also handles user authentication decisions.

**MCP Client**

MCP Client is generated by the MCP Host application and maintains isolated connections for each MCP Server. __Each Client has a 1:1 relationship with a specific Server and establishes one session per Server. Communication with the MCP Server involves exchanging JSON-RPC 2.0-based messages. The Client handles protocol negotiation and capability exchange with the Server during connection and routes protocol messages bidirectionally.

The Client has 3 functions: **Roots, Sampling, and Elicitation**. The availability of these functions is configured on the Client side, and this information is exchanged during connection with the Server. The Server can only use the functions that are available.

**Roots** is a security function that explicitly restricts the Server's file system operation range based on configuration. This function can prevent access to sensitive information such as authentication credentials. **Sampling** is a function that allows the Server to indirectly access the LLM. Why is this function necessary? The Server's primary responsibility is to provide tools, and by specification, it does not have a direct connection to the LLM. This function allows the Server to indirectly utilize the LLM through the Client. **Elicitation** is a function that allows the Server to indirectly request information input from the user. For example, if the Server needs to ask the user for their Github username, it can use Elicitation to obtain the username.

**MCP Server**

MCP Server provides **Resources, Prompts, and Tools** to the Client. **Resources** provide prompt templates for the AI model to use, **Prompts** provide template messages for users, and **Tools** provide tool usage functionality for the AI model.

You may have only seen or used cases where the MCP Server is on a local machine. Streamable HTTP, which we will explain in detail later, can also have MCP Servers existing remotely.

**MCP Functions Summary**

| Function | Role | Client Responsibility | Server Responsibility |
|------|------|------------|------------|
| Roots | Restrict Server's file system operation range | Define and manage accessible range | Operate only within defined boundaries |
| Sampling | Allow Server to use LLM | Manage access to LLM | Provide appropriate prompts and arguments, process results |
| Elicitation | Collect structured data from users | Request information input from users, validate input and send to Server | Define schema and specify required data structure |
| Prompts | Provide prompt templates | Retrieve templates, present to users and use them | Define templates and provide schema for arguments |
| Resources | Provide resources such as files | Retrieve resources, display and use appropriately | Manage resources and make them accessible via URI |
| Tools | Provide interaction functionality with external systems | Call tools, process and display results | Implement tools and define input/output schemas |

Client and Server explicitly declare the features they support during initial connection using Capability Negotiation. The available protocol features during the session are determined based on this initial declaration. The session flow is as follows: **1/** The Host initializes the Client, **2/** The Client initializes a session with the Server specifying its capabilities, **3/** The Server responds with its supported capabilities, completing the negotiation.

## Base Protocol

MCP adopts [JSON-RPC 2.0](https://www.jsonrpc.org/specification) as its base protocol and extends it for tool usage. Please refer to the JSON-RPC 2.0 specification for details. One main difference at the protocol level between MCP and JSON-RPC 2.0 is that MCP requires request IDs and does not allow null. The message structure is also slightly more restrictive than JSON-RPC 2.0, prohibiting duplicate request IDs.

While MCP adds specific functionality to JSON-RPC 2.0, these additions are primarily implemented using the _params_ field in request objects and the _result_ field in response objects defined in JSON-RPC 2.0. In simple terms, MCP defines additional specifications using the areas in JSON-RPC 2.0 that can handle arbitrary values.

JSON-RPC 2.0 is a protocol that does not depend on the underlying transport layer (which also encompasses the application layer in the OSI reference model). In simpler terms, **you can use the same data format whether it's HTTP, WebSocket, or inter-process communication**.

_Requests object_ 

```json
{
  jsonrpc: "2.0";
  id: string | number;
  method: string;
  params?: { # MCP-specific additional specifications are defined in this params area
    [key: string]: unknown;
  };
}
```

_Notifications object (subobject of Requests)_

```json
{ # Does not have an id
  jsonrpc: "2.0";
  method: string;
  params?: {
    [key: string]: unknown;
  };
}
```

_Responses object_

```json
{
  jsonrpc: "2.0";
  id: string | number;
  result?: {  # MCP-specific additional specifications are defined in this result area
    [key: string]: unknown;
  }
  error?: {
    code: number;
    message: string;
    data?: unknown;
  }
}
```

### Other MCP Protocol Functional Specifications

**_meta field**

MCP reserves the `_meta` property/parameter, allowing Clients and Servers to add additional metadata to their interactions. The key name format consists of two segments: an optional **prefix** and a **name**. This `_meta` can be used, for example, to pass JWT token information to the MCP Server. **Understand that this parameter allows for very flexible usage!**

**Authentication**

While not defined in JSON-RPC 2.0, authentication is required as a `SHOULD`. MCP provides an authentication framework for HTTP, and implementations using HTTP-based transport should comply with this specification. On the other hand, implementations using STDIO transport should not follow this specification and should instead obtain authentication information from the environment. We will cover this in detail in subsequent Chapters.

**Schema**

The complete specification of the protocol is defined as a [Typescript schema](https://github.com/modelcontextprotocol/specification/blob/main/schema/2025-06-18/schema.ts). This is the authoritative source for all protocol messages and structures.

## Summary

In this Chapter, we explained the components that appear in MCP and the Base Protocol between Client ↔ Server. The MCP Base Protocol is based on JSON-RPC 2.0 and provides schema definitions for additional functionality. Future protocol extensions will likely continue to use JSON-RPC 2.0 to maintain backward compatibility. In subsequent Chapters, we will explain the detailed functionality of each MCP component, the sequence of Protocol exchanges, and more.
